// Generated by CoffeeScript 1.6.3
(function () {
    var VisConnector, getBBoxWithoutCanvas, getMapping, getMappingNominal, getMappingNumeric, getMappings, getSelectedSet, hasMappingNominal, prepareMarkForDisplay, restylingApp, scaleNode, setupModal, transformedBoundingBox, unorderedEquals, updateNode,
        __bind = function (fn, me) {
            return function () {
                return fn.apply(me, arguments);
            };
        },
        __indexOf = [].indexOf || function (item) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item) return i;
            }
            return -1;
        };

    unorderedEquals = function (arr1, arr2) {
        return _.difference(arr1, arr2).length === 0;
    };

    VisConnector = (function () {
        function VisConnector() {
            this.processPayload = __bind(this.processPayload, this);
            this.getDataSetTable = __bind(this.getDataSetTable, this);
            this.sendUpdate = __bind(this.sendUpdate, this);
            this.initConnection = __bind(this.initConnection, this);
            var _this = this;
            chrome.runtime.onMessage.addListener(function (message, sender, sendResponse) {
                var angularScope, newMarkInfo;
                if (message.type === "syn") {
                    _this.initConnection(sender.tab.id);
                    _this.dataSets = _this.processPayload(message.payload);
                    _this.tableViews = [];
                    $.each(_this.dataSets, function (i, dataSet) {
                        dataSet.dataTypes = _this.inferTypes(dataSet.d3Data);
                        dataSet.visTypes = _this.inferTypes(dataSet.visData);
                        return dataSet.mappings = getMappings(dataSet);
                    });
                    angularScope = angular.element($('body')).scope();
                    angularScope.$apply(function () {
                        angularScope.mappings = getMappings(_this.dataSets[0]);
                        return angularScope.dataSets = _this.dataSets;
                    });
                } else if (message.type === "markUpdate") {
                    newMarkInfo = {
                        'tag': message.payload.nodeText,
                        'css': message.payload.cssText,
                        'bbox': message.payload.bbox
                    };
                    angularScope = angular.element($('body')).scope();
                    angularScope.$apply(function () {
                        var dataSet, index, markIndex, _i, _len, _ref, _results;
                        _ref = angularScope.dataSets;
                        _results = [];
                        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
                            dataSet = _ref[index];
                            markIndex = dataSet['ids'].indexOf(message.payload.id);
                            if (markIndex !== -1) {
                                _results.push(angularScope.dataSets[index]['node'][markIndex] = newMarkInfo);
                            } else {
                                _results.push(void 0);
                            }
                        }
                        return _results;
                    });
                }
                return setupModal();
            });
        }

        VisConnector.prototype.initConnection = function (tabId) {
            return this.port = chrome.tabs.connect(tabId, {
                name: 'd3annot'
            });
        };

        VisConnector.prototype.sendUpdate = function (message) {
            return this.port.postMessage(message);
        };

        VisConnector.prototype.getDataSetTable = function (dataSetId) {
            return this.tableViews[dataSetId].dataTable;
        };

        VisConnector.prototype.inferTypes = function (dataObj) {
            var dataAttr, dataTypes, newCol;
            dataTypes = {};
            for (dataAttr in dataObj) {
                dataTypes[dataAttr] = this.inferDataColType(dataObj[dataAttr]);
                if (dataTypes[dataAttr] === "numeric") {
                    newCol = _.map(dataObj[dataAttr], function (d) {
                        return +parseFloat(d).toFixed(3);
                    });
                    dataObj[dataAttr] = newCol;
                }
            }
            return dataTypes;
        };

        VisConnector.prototype.inferDataColType = function (colData) {
            var isNull, isNum, row, _i, _len;
            isNum = true;
            isNull = true;
            for (_i = 0, _len = colData.length; _i < _len; _i++) {
                row = colData[_i];
                if (row) {
                    isNull = false;
                }
                if (isNaN(parseFloat(row))) {
                    isNum = false;
                }
            }
            if (isNum) {
                return "numeric";
            } else if (isNull) {
                return "null";
            } else {
                return "nominal";
            }
        };

        VisConnector.prototype.extractVisData = function (node, nodeText, cssText, bbox) {
            var canvasWidth, newNode, nodeAttrs, styleFill, styleStroke, svg, visRow;
            visRow = {};
            nodeAttrs = {};
            $.each(node.attributes, function (j, attr) {
                return nodeAttrs[attr.name] = attr.value;
            });
            node.style.cssText = cssText;
            newNode = prepareMarkForDisplay(nodeText, cssText);
            svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            canvasWidth = 20;
            svg.setAttribute("width", "20");
            svg.setAttribute("height", "20");
            $('body')[0].appendChild(svg);
            svg.appendChild(newNode);
            styleFill = d3.select(newNode).style('fill');
            styleStroke = d3.select(newNode).style('stroke');
            $(svg).remove();
            visRow["shape"] = node.tagName.toLowerCase();
            if (!styleFill) {
                visRow["color"] = nodeAttrs["fill"];
            } else {
                visRow["color"] = styleFill;
            }
            if (!styleStroke) {
                visRow["stroke"] = nodeAttrs["stroke"];
            } else {
                visRow["stroke"] = styleStroke;
            }
            visRow["stroke-width"] = nodeAttrs["stroke-width"];
            visRow["x-position"] = bbox.x + (bbox.width / 2);
            visRow["y-position"] = bbox.y + (bbox.height / 2);
            if (visRow["shape"] === "circle") {
                visRow["width"] = 2 * parseFloat(nodeAttrs["r"]);
                visRow["height"] = 2 * parseFloat(nodeAttrs["r"]);
                visRow["area"] = Math.PI * parseFloat(nodeAttrs["r"]) * parseFloat(nodeAttrs["r"]);
            } else {
                visRow["width"] = bbox.width;
                visRow["height"] = bbox.height;
                visRow["area"] = bbox.width * bbox.height;
            }
            return visRow;
        };

        VisConnector.prototype.extractVisSchema = function (node) {
            var shape;
            shape = node.tagName.toLowerCase();
            return {
                "shape": [],
                "color": [],
                "stroke": [],
                "stroke-width": [],
                "width": [],
                "height": [],
                "area": [],
                "x-position": [],
                "y-position": []
            };
        };

        VisConnector.prototype.findSchema = function (data, d3Data, tagName) {
            var found, thisSchema;
            thisSchema = null;
            if (d3Data instanceof Object) {
                thisSchema = Object.keys(d3Data);
            } else {
                thisSchema = ["scalar"];
            }
            thisSchema.push(tagName);
            found = -1;
            $.each(data, function (i, dataSet) {
                if (unorderedEquals(dataSet.schema, thisSchema)) {
                    found = i;
                    return false;
                }
            });
            return found;
        };

        VisConnector.prototype.processPayload = function (payload) {
            var data, schema_count,
                _this = this;
            data = [];
            schema_count = -1;
            $.each(payload, function (i, obj) {
                var d3Data, newSchema, node, schema, visRow;
                d3Data = obj.d3Data;
                node = prepareMarkForDisplay(obj.nodeText, obj.cssText);
                schema = -1;
                if (d3Data instanceof Object) {
                    schema = _this.findSchema(data, d3Data, node.tagName);
                    if (schema === -1) {
                        newSchema = Object.keys(d3Data);
                        newSchema.push(node.tagName);
                        schema_count++;
                        schema = schema_count;
                        data[schema] = {};
                        data[schema].schema = newSchema;
                        data[schema].d3Data = {};
                        data[schema].d3Data["deconID"] = [];
                        $.each(Object.keys(d3Data), function (j, key) {
                            return data[schema].d3Data[key] = [];
                        });
                        data[schema].visData = _this.extractVisSchema(node);
                        data[schema].visSchema = _.keys(data[schema].visData);
                    }
                    $.each(d3Data, function (prop, val) {
                        return data[schema].d3Data[prop].push(val);
                    });
                    data[schema].d3Data["deconID"].push(obj.id);
                } else {
                    if (d3Data === void 0 || d3Data === null) {
                        return true;
                    }
                    schema = _this.findSchema(data, d3Data, node.tagName);
                    if (schema === -1) {
                        schema_count++;
                        schema = schema_count;
                        data[schema] = {};
                        data[schema].schema = ["scalar"];
                        data[schema].d3Data = {
                            "deconID": [obj.id],
                            "scalar": [d3Data]
                        };
                        data[schema].visData = _this.extractVisSchema(node);
                        data[schema].visSchema = _.keys(data[schema].visData);
                    } else {
                        data[schema].d3Data["scalar"].push(d3Data);
                        data[schema].d3Data["deconID"].push(obj.id);
                    }
                }
                visRow = _this.extractVisData(node, obj.nodeText, obj.cssText, obj.bbox);
                $.each(Object.keys(data[schema].visData), function (j, key) {
                    return data[schema].visData[key].push(visRow[key]);
                });
                if (data[schema].hasOwnProperty('node')) {
                    data[schema]['node'].push({
                        'tag': obj.nodeText,
                        'css': obj.cssText,
                        'bbox': obj.bbox
                    });
                } else {
                    data[schema]['node'] = [
                        {
                            'tag': obj.nodeText,
                            'css': obj.cssText,
                            'bbox': obj.bbox
                        }
                    ];
                }
                if (data[schema].hasOwnProperty('ids')) {
                    return data[schema]['ids'].push(obj.id);
                } else {
                    return data[schema]['ids'] = [obj.id];
                }
            });
            $.each(data, function (i, dataSet) {
                return dataSet.numEls = dataSet.d3Data[dataSet.schema[0]].length;
            });
            return data;
        };

        return VisConnector;

    })();

    getBBoxWithoutCanvas = function (node) {
        var bbox, svg;
        svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.appendChild(node);
        $('body')[0].appendChild(svg);
        bbox = node.getBBox();
        svg.remove();
        return bbox;
    };

    getMappings = function (dataSet) {
        var dataAttr, ind, mapping, mappings, removed, visAttr, visAttrMap, visAttrs, visAttrsWithLinear, _i, _j, _len, _ref, _ref1, _ref2;
        mappings = {};
        for (dataAttr in dataSet.d3Data) {
            for (visAttr in dataSet.visData) {
                mapping = getMapping(dataAttr, visAttr, dataSet);
                if (mapping) {
                    if (mappings.hasOwnProperty(dataAttr)) {
                        mappings[dataAttr].push([visAttr, mapping]);
                    } else {
                        mappings[dataAttr] = [
                            [visAttr, mapping]
                        ];
                    }
                }
            }
        }
        visAttrsWithLinear = [];
        for (dataAttr in mappings) {
            visAttrs = mappings[dataAttr];
            for (_i = 0, _len = visAttrs.length; _i < _len; _i++) {
                visAttrMap = visAttrs[_i];
                if (visAttrMap[1].hasOwnProperty('isNumericMapping')) {
                    if (!(_ref = visAttrMap[0], __indexOf.call(visAttrsWithLinear, _ref) >= 0)) {
                        visAttrsWithLinear.push(visAttrMap[0]);
                    }
                }
            }
        }
        for (dataAttr in mappings) {
            visAttrs = mappings[dataAttr];
            removed = 0;
            for (ind = _j = 0, _ref1 = visAttrs.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; ind = 0 <= _ref1 ? ++_j : --_j) {
                visAttrMap = visAttrs[ind - removed];
                if (!visAttrMap[1].hasOwnProperty('isNumericMapping') && (_ref2 = visAttrMap[0], __indexOf.call(visAttrsWithLinear, _ref2) >= 0)) {
                    visAttrs.splice(ind - removed, 1);
                    ++removed;
                }
            }
        }
        return mappings;
    };

    getMapping = function (dataAttr, visAttr, dataSet) {
        var dataAttrCol, dataAttrType, visAttrCol, visAttrType;
        dataAttrType = dataSet.dataTypes[dataAttr];
        visAttrType = dataSet.visTypes[visAttr];
        dataAttrCol = dataSet.d3Data[dataAttr];
        visAttrCol = dataSet.visData[visAttr];
        if (dataAttrType === "null" || visAttrType === "null") {
            return false;
        } else if (!(dataAttrType === visAttrType) || (dataAttrType === "nominal")) {
            return getMappingNominal(dataAttrCol, visAttrCol, dataSet['ids']);
        } else {
            return getMappingNumeric(dataAttrCol, visAttrCol, dataSet['ids']);
        }
        return null;
    };

    getMappingNominal = function (col1, col2, ids) {
        var attr, index, mappedVals, mapping, mapping_ids, row1, val, _i, _len;
        mapping = {};
        mapping_ids = {};
        for (index = _i = 0, _len = col1.length; _i < _len; index = ++_i) {
            row1 = col1[index];
            if (mapping.hasOwnProperty(row1)) {
                mapping[row1].push(col2[index]);
                mapping_ids[row1].push(ids[index]);
            } else {
                mapping[row1] = [col2[index]];
                mapping_ids[row1] = [ids[index]];
            }
        }
        for (val in mapping) {
            mapping[val] = _.uniq(mapping[val]);
            if (mapping[val].length > 1) {
                return false;
            }
        }
        mappedVals = _.flatten(_.values(mapping));
        if (_.uniq(mappedVals).length < mappedVals.length) {
            return false;
        }
        for (attr in mapping) {
            mapping[attr] = [mapping[attr], mapping_ids[attr]];
        }
        return mapping;
    };

    hasMappingNominal = function (col1, col2) {
        if (getMappingNominal(col1, col2)) {
            return true;
        } else {
            return false;
        }
    };

    getMappingNumeric = function (col1, col2, ids) {
        var linear_regression, linear_regression_line, mapping, rSquared, zipped;
        mapping = {};
        col1 = _.map(col1, function (v) {
            return parseFloat(v);
        });
        col2 = _.map(col2, function (v) {
            return parseFloat(v);
        });
        zipped = _.zip(col1, col2);
        linear_regression = ss.linear_regression().data(zipped);
        linear_regression_line = linear_regression.line();
        rSquared = ss.r_squared(zipped, linear_regression_line);
        if (jStat.stdev(col1) === 0 || jStat.stdev(col2) === 0) {
            return false;
        }
        if (rSquared > 0.95 && !(isNaN(rSquared))) {
            mapping.dataMin = _.min(col1);
            mapping.dataMinIndex = col1.indexOf(mapping.dataMin);
            mapping.dataMax = _.max(col1);
            mapping.dataMaxIndex = col1.indexOf(mapping.dataMax);
            mapping.visMin = col2[mapping.dataMinIndex];
            mapping.visMinIndex = mapping.dataMinIndex;
            mapping.visMax = col2[mapping.dataMaxIndex];
            mapping.visMaxIndex = mapping.dataMaxIndex;
            mapping.isNumericMapping = true;
            mapping.ids = ids;
            return mapping;
        }
        return getMappingNominal(col1, col2, ids);
    };

    getSelectedSet = function (dataSet) {
        var id, key, newDataSet, newList, sel, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        newDataSet = $.extend(true, {}, dataSet);
        for (key in newDataSet.d3Data) {
            newList = [];
            _ref = newDataSet.selections;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                sel = _ref[_i];
                newList.push(newDataSet.d3Data[key][sel]);
            }
            newDataSet.d3Data[key] = newList;
        }
        for (key in newDataSet.visData) {
            newList = [];
            _ref1 = newDataSet.selections;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                sel = _ref1[_j];
                newList.push(newDataSet.visData[key][sel]);
            }
            newDataSet.visData[key] = newList;
        }
        _ref2 = newDataSet['ids'];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            id = _ref2[_k];
            newList = [];
            _ref3 = newDataSet.selections;
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
                sel = _ref3[_l];
                newList.push(newDataSet['ids'][sel]);
            }
            newDataSet['ids'][key] = newList;
        }
        return newDataSet;
    };

    restylingApp = angular.module('restylingApp', []);

    restylingApp.controller('MappingListCtrl', function ($scope, orderByFilter) {
        $scope._ = _;
        $scope.currentDataSet = 0;
        $scope.chosenMappings = null;
        $scope.addMappingDialog = false;
        $scope.addForm = {};
        $scope.addFormAction = function (action) {
            var uniqVal, uniqVals, _i, _len, _results;
            $scope.addForm.action = action;
            if (action === 'Nominal') {
                uniqVals = _.uniq($scope.dataSets[$scope.currentDataSet].d3Data[$scope.addForm.mapDataAttr]);
                $scope.addForm.nominalMapData = {};
                _results = [];
                for (_i = 0, _len = uniqVals.length; _i < _len; _i++) {
                    uniqVal = uniqVals[_i];
                    _results.push($scope.addForm.nominalMapData[uniqVal] = '');
                }
                return _results;
            }
        };
        $scope.changeFormDataAttr = function (attr) {
            if (attr == null) {
                attr = null;
            }
            $scope.addForm.mapDataAttr = attr;
            if ($scope.addForm.action === 'Nominal') {
                return $scope.addFormAction('Nominal');
            }
        };
        $scope.clearAddForm = function () {
            return $scope.addForm = {};
        };
        $scope.removeMapping = function (dataField, mappedAttr) {
            var dataSet, ind, mapping, message, _i, _j, _len, _ref, _ref1;
            dataSet = $scope.dataSets[$scope.currentDataSet];
            _ref = dataSet.mappings[dataField];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                mapping = _ref[_i];
                if (mapping[0] === mappedAttr[0]) {
                    ind = dataSet.mappings[dataField].indexOf(mapping);
                    dataSet.mappings[dataField].splice(ind, 1);
                    break;
                }
            }
            for (ind = _j = 0, _ref1 = dataSet.visData[mappedAttr[0]] - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; ind = 0 <= _ref1 ? ++_j : --_j) {
                dataSet.visData[mappedAttr[0]][ind] = dataSet.visData[mappedAttr[0]][0];
            }
            message = {
                type: "update",
                attr: mappedAttr[0],
                val: dataSet.visData[mappedAttr[0]][0],
                nodes: dataSet['ids']
            };
            console.log(message);
            return window.connector.sendUpdate(message);
        };
        $scope.getSelections = function () {
            var sels;
            sels = $scope.dataSets[$scope.currentDataSet].selections;
            if ((!sels) || sels.length === 0) {
                return $scope.dataSets[$scope.currentDataSet]['ids'];
            } else {
                return sels;
            }
        };
        $scope.submitValChange = function () {
            var message;
            message = {
                type: "update",
                attr: $scope.addForm.changeAttr,
                val: $scope.addForm.changedAttrValue,
                nodes: $scope.getSelections()
            };
            window.connector.sendUpdate(message);
            return $scope.updateData(message);
        };
        $scope.updateData = function (updateMessage) {
            var attr, dataSet, id, ids, ind, val, _i, _len, _results;
            attr = updateMessage.attr;
            val = updateMessage.val;
            ids = updateMessage.nodes;
            _results = [];
            for (_i = 0, _len = ids.length; _i < _len; _i++) {
                id = ids[_i];
                dataSet = $scope.dataSets[$scope.currentDataSet];
                ind = dataSet['ids'].indexOf(id);
                if (attr === "x-position" || attr === "y-position" || attr === "width" || attr === "height") {
                    val = parseFloat(val);
                }
                _results.push(dataSet.visData[attr][ind] = val);
            }
            return _results;
        };
        $scope.setChosenMappings = function () {
            $scope.addMappingDialog = false;
            return $scope.chosenMappings = $scope.dataSets[$scope.currentDataSet].mappings;
        };
        $scope.getIndexForDataVal = function (attr, val) {
            var dataSet;
            dataSet = $scope.dataSets[$scope.currentDataSet];
            return dataSet.d3Data[attr].indexOf(val);
        };
        $scope.submitAttrClassChange = function ($event, attrClass, attrName) {
            var dataSet, i, ids, inds, message, newVal, val, _i, _len, _ref;
            if ($event.keyCode === 13) {
                dataSet = $scope.dataSets[$scope.currentDataSet];
                newVal = angular.element($event.target).val();
                inds = [];
                _ref = dataSet.visData[attrName];
                for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                    val = _ref[i];
                    if (val === attrClass) {
                        inds.push(i);
                    }
                }
                ids = _.map(inds, function (ind) {
                    return dataSet['ids'][ind];
                });
                message = {
                    type: "update",
                    attr: attrName,
                    val: newVal,
                    nodes: ids
                };
                return window.connector.sendUpdate(message);
            }
        };
        $scope.submitNewLinearMapping = function ($event) {
            var data, dataMax, dataMin, dataVal, id, ind, line, message, newAttrVal, newMax, newMin, regression, _i, _len, _ref, _results;
            if ($event.keyCode === 13) {
                data = $scope.dataSets[$scope.currentDataSet];
                dataMin = _.min(data.d3Data[$scope.addForm.mapDataAttr]);
                dataMax = _.max(data.d3Data[$scope.addForm.mapDataAttr]);
                newMin = null;
                newMax = null;
                if ($scope.addForm.mapVisAttr === "color" || $scope.addForm.MapVisAttr === "stroke") {
                    line = d3.scale.linear().domain([dataMin, dataMax]).range([$scope.addForm.newMin, $scope.addForm.newMax]);
                } else {
                    newMin = [dataMin, parseFloat($scope.addForm.newMin)];
                    newMax = [dataMax, parseFloat($scope.addForm.newMax)];
                    regression = ss.linear_regression().data([newMin, newMax]);
                    line = regression.line();
                }
                _ref = $scope.getSelections();
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    id = _ref[_i];
                    ind = data['ids'].indexOf(id);
                    dataVal = data.d3Data[$scope.addForm.mapDataAttr][ind];
                    newAttrVal = line(dataVal);
                    message = {
                        type: "update",
                        attr: $scope.addForm.mapVisAttr,
                        val: newAttrVal,
                        nodes: [id]
                    };
                    _results.push(window.connector.sendUpdate(message));
                }
                return _results;
            }
        };
        $scope.submitLinearMappingChange = function ($event, dataAttr, mapping) {
            var currDataSet, dataVal, id, ind, line, message, newAttrVal, newMax, newMin, regression, _i, _len, _ref, _results;
            if ($event.keyCode === 13) {
                newMin = [mapping[1].dataMin, parseFloat(mapping[1].visMin)];
                newMax = [mapping[1].dataMax, parseFloat(mapping[1].visMax)];
                regression = ss.linear_regression().data([newMin, newMax]);
                line = regression.line();
                currDataSet = $scope.dataSets[$scope.currentDataSet];
                _ref = mapping[1].ids;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    id = _ref[_i];
                    ind = currDataSet['ids'].indexOf(id);
                    dataVal = currDataSet.d3Data[dataAttr][ind];
                    newAttrVal = line(dataVal);
                    message = {
                        type: "update",
                        attr: mapping[0],
                        val: newAttrVal,
                        nodes: [id]
                    };
                    _results.push(window.connector.sendUpdate(message));
                }
                return _results;
            }
        };
        $scope.isMapped = function (visAttr) {
            var dataField, dataSet, mapping, _i, _len, _ref;
            dataSet = $scope.dataSets[$scope.currentDataSet];
            for (dataField in dataSet.mappings) {
                _ref = dataSet.mappings[dataField];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    mapping = _ref[_i];
                    if (mapping[0] === visAttr) {
                        return dataField;
                    }
                }
            }
            return false;
        };
        $scope.formCreateNominalMapping = function ($event, dataAttrName, dataAttrCat) {
            if ($event.keyCode === 13) {
                return console.log($scope.addForm.nominalMapData);
            }
        };
        $scope.submitNominalMappingChange = function ($event, dataAttr, mappedAttr, mapped_to) {
            var message, newCategoryVal, newIds;
            if ($event.keyCode === 13) {
                newCategoryVal = angular.element($event.target).val();
                newIds = mapped_to[1];
                mapped_to[0][0] = newCategoryVal;
                message = {
                    type: "update",
                    attr: mappedAttr,
                    val: newCategoryVal,
                    nodes: newIds
                };
                return window.connector.sendUpdate(message);
            }
        };
        $scope.selectDataSet = function (dataSet) {
            $scope.currentDataSet = $scope.dataSets.indexOf(dataSet);
            $scope.clearAddForm();
            $scope.setChosenMappings();
            $scope.currentDialog = "viewMappingDialog";
            if ($scope.dataSets[$scope.currentDataSet].selections && $scope.dataSets[$scope.currentDataSet].selections.length > 0) {
                return $scope.selectedSet = getSelectedSet($scope.dataSets[$scope.currentDataSet]);
            } else {
                return $scope.selectedSet = $scope.dataSets[$scope.currentDataSet];
            }
        };
        $scope.nextIndex = 0;
        $scope.getNextIndex = function () {
            return ++$scope.nextIndex;
        };
        $scope.getMappings = function () {
            return $scope.dataSets[$scope.currentDataSet].mappings = getMappings($scope.dataSets[$scope.currentDataSet]);
            /*
             else
             selectedSet = getSelectedSet($scope.dataSets[$scope.currentDataSet])
             console.log selectedSet
             $scope.selectedSet = selectedSet
             $scope.dataSets[$scope.currentDataSet].mappings =
             getMappings(selectedSet)
             */

        };
        $scope.toggleSelect = function (dataSet, elemIndex) {
            if (!dataSet.selections) {
                dataSet.selections = [elemIndex];
            } else {
                if (__indexOf.call(dataSet.selections, elemIndex) >= 0) {
                    dataSet.selections = _.without(dataSet.selections, elemIndex);
                } else {
                    dataSet.selections.push(elemIndex);
                }
            }
            if (dataSet.selections && dataSet.selections.length > 0) {
                return $scope.selectedSet = getSelectedSet(dataSet);
            } else {
                return $scope.selectedSet = dataSet;
            }
        };
        return $scope.itemClass = function (dataSet, elemIndex) {
            if (!dataSet.hasOwnProperty('selections')) {
                return void 0;
            }
            if (__indexOf.call(dataSet.selections, elemIndex) >= 0) {
                return 'selected';
            }
            return void 0;
        };
    });

    prepareMarkForDisplay = function (nodeText, cssText) {
        var attr, htmlNode, r, svgNode, tagName, _i, _len, _ref;
        htmlNode = $(nodeText)[0];
        svgNode = document.createElementNS("http://www.w3.org/2000/svg", htmlNode.tagName.toLowerCase());
        htmlNode.style.cssText = cssText;
        tagName = $(htmlNode).prop("tagName").toLowerCase();
        _ref = htmlNode.attributes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            attr = _ref[_i];
            svgNode.setAttribute(attr.name, attr.value);
        }
        svgNode.setAttribute("vector-effect", "non-scaling-stroke");
        if ($(htmlNode).text()) {
            svgNode.textContent = $(htmlNode).text();
        }
        d3.select(svgNode).attr("transform", void 0);
        if (tagName === "circle" || tagName === "ellipse") {
            r = d3.select(svgNode).attr("r");
            d3.select(svgNode).attr("cx", 0);
            d3.select(svgNode).attr("cy", 0);
        } else {
            d3.select(svgNode).attr("x", 0);
            d3.select(svgNode).attr("y", 0);
        }
        return svgNode;
    };

    restylingApp.directive('svgInject', function ($compile) {
        return {
            scope: {
                ind: '=ind',
                data: '=data'
            },
            link: function (scope, element, attrs, controller) {
                return scope.$watch("data['node'][ind]", (function (newValue, oldValue) {
                    var canvasWidth, mark, markInfo, maxHeight, maxWidth, newScale, newTranslate, scaleDimVal, svg;
                    svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    canvasWidth = 20;
                    svg.setAttribute("width", "20");
                    svg.setAttribute("height", "20");
                    $.each(element[0].children, function (e, i) {
                        return $(this).remove();
                    });
                    element[0].appendChild(svg);
                    markInfo = scope.data['node'][scope.ind];
                    maxWidth = _.max(scope.data.visData['width']);
                    maxHeight = _.max(scope.data.visData['height']);
                    mark = prepareMarkForDisplay(markInfo['tag'], markInfo['css']);
                    svg.appendChild(mark);
                    scaleDimVal = maxHeight;
                    if (maxWidth > maxHeight) {
                        scaleDimVal = maxWidth;
                    }
                    newTranslate = svg.createSVGTransform();
                    newTranslate.setTranslate(canvasWidth / 2, canvasWidth / 2);
                    newScale = svg.createSVGTransform();
                    newScale.setScale((canvasWidth - 2) / scaleDimVal, (canvasWidth - 2) / scaleDimVal);
                    mark.transform.baseVal.appendItem(newTranslate);
                    scaleNode(mark, scope.data.visData['width'][scope.ind], scope.data.visData['height'][scope.ind], svg);
                    return mark.transform.baseVal.appendItem(newScale);
                }), true);
            }
        };
    });

    transformedBoundingBox = function (el, to) {
        var bb, m, pt, pts, svg, xMax, xMin, yMax, yMin, _i, _len;
        bb = el.getBBox();
        svg = el.ownerSVGElement;
        if (!to) {
            to = svg;
        }
        m = el.getTransformToElement(to);
        pts = [svg.createSVGPoint(), svg.createSVGPoint(), svg.createSVGPoint(), svg.createSVGPoint()];
        pts[0].x = bb.x;
        pts[0].y = bb.y;
        pts[1].x = bb.x + bb.width;
        pts[1].y = bb.y;
        pts[2].x = bb.x + bb.width;
        pts[2].y = bb.y + bb.height;
        pts[3].x = bb.x;
        pts[3].y = bb.y + bb.height;
        xMin = Infinity;
        xMax = -Infinity;
        yMin = Infinity;
        yMax = -Infinity;
        for (_i = 0, _len = pts.length; _i < _len; _i++) {
            pt = pts[_i];
            pt = pt.matrixTransform(m);
            xMin = Math.min(xMin, pt.x);
            xMax = Math.max(xMax, pt.x);
            yMin = Math.min(yMin, pt.y);
            yMax = Math.max(yMax, pt.y);
        }
        bb.x = xMin;
        bb.width = xMax - xMin;
        bb.y = yMin;
        bb.height = yMax - yMin;
        return bb;
    };

    window.transformedBoundingBox = transformedBoundingBox;

    scaleNode = function (node, width, height, svg) {
        var bbox, heightScale, scale, widthScale;
        scale = svg.createSVGTransform();
        bbox = window.transformedBoundingBox(node);
        widthScale = width / bbox.width;
        heightScale = height / bbox.height;
        if (width === 0) {
            widthScale = 1;
        } else if (bbox.width === 0) {
            widthScale = width;
        }
        if (height === 0) {
            heightScale = 1;
        } else if (bbox.height === 0) {
            heightScale = height;
        }
        scale.setScale(widthScale, heightScale);
        node.transform.baseVal.appendItem(scale);
        return bbox = window.transformedBoundingBox(node);
    };

    updateNode = function (origNode, origBBox, attr, val) {
        var bbox, clone, currAttr, currentTag, cx, cy, newHeight, newWidth, newX, newY, parentNode, parentOffset, parentTrans, scale, svg, trans, translate, x, xtranslate, y, ytranslate, _i, _len, _ref, _ref1;
        parentNode = origNode.parentElement;
        svg = getRootSVG(origNode);
        clone = null;
        currentTag = origNode.tagName.toLowerCase();
        if (attr === "shape") {
            clone = getNodeFromShape(val);
        } else if (currentTag === "polygon") {
            clone = getNodeFromShape(currentTag, origNode.getAttribute("points"));
        } else {
            clone = getNodeFromShape(currentTag);
        }
        parentNode.appendChild(clone);
        bbox = transformedBoundingBox(clone, svg);
        _ref = origNode.attributes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            currAttr = _ref[_i];
            if (!((_ref1 = currAttr.name) === "id" || _ref1 === "cx" || _ref1 === "cy" || _ref1 === "x" || _ref1 === "y" || _ref1 === "r" || _ref1 === "transform" || _ref1 === "points" || _ref1 === "clip-path" || _ref1 === "requiredFeatures" || _ref1 === "systemLanguage" || _ref1 === "requiredExtensions" || _ref1 === "vector-effect")) {
                clone.setAttribute(currAttr.name, currAttr.value);
            }
        }
        clone.setAttribute("vector-effect", "non-scaling-stroke");
        if (attr === "color") {
            attr = "fill";
            d3.select(clone).style("fill", val);
        } else if (!(attr === "x-position" || attr === "y-position" || attr === "shape" || attr === "width" || attr === "height")) {
            d3.select(clone).attr(attr, val);
        }
        translate = svg.createSVGTransform();
        parentTrans = origNode.getTransformToElement(svg);
        trans = clone.getTransformToElement(svg);
        parentOffset = [0, 0];
        if (currentTag === "circle") {
            cx = parseFloat(d3.select(origNode).attr("cx"));
            cy = parseFloat(d3.select(origNode).attr("cy"));
            if (cx) {
                parentOffset[0] = cx;
            }
            if (cy) {
                parentOffset[1] = cy;
            }
        } else if (currentTag === "rect") {
            x = parseFloat(d3.select(origNode).attr("x"));
            y = parseFloat(d3.select(origNode).attr("y"));
            if (x) {
                parentOffset[0] = x;
            }
            if (y) {
                parentOffset[1] = y;
            }
        }
        translate.setTranslate(parentTrans.e - trans.e + parentOffset[0], parentTrans.f - trans.f + parentOffset[1]);
        clone.transform.baseVal.appendItem(translate);
        if (attr === "x-position") {
            newX = parseFloat(val);
            xtranslate = svg.createSVGTransform();
            xtranslate.setTranslate(newX - origBBox.x, 0);
            clone.transform.baseVal.appendItem(xtranslate);
        } else if (attr === "y-position") {
            newY = parseFloat(val);
            ytranslate = svg.createSVGTransform();
            ytranslate.setTranslate(0, newY - origBBox.y);
            clone.transform.baseVal.appendItem(ytranslate);
        }
        scale = svg.createSVGTransform();
        if (val === "circle") {
            if (origBBox.width < origBBox.height) {
                scale.setScale(origBBox.width / bbox.width, origBBox.width / bbox.width);
            } else {
                scale.setScale(origBBox.height / bbox.height, origBBox.height / bbox.height);
            }
        } else if (attr === "width") {
            newWidth = parseFloat(val);
            scale.setScale(newWidth / bbox.width, origBBox.height / bbox.height);
        } else if (attr === "height") {
            newHeight = parseFloat(val);
            scale.setScale(origBBox.width / bbox.width, newHeight / bbox.height);
        } else {
            scale.setScale(origBBox.width / bbox.width, origBBox.height / bbox.height);
        }
        return clone.transform.baseVal.appendItem(scale);
    };

    /*
     prepareMarkFromVisData = (visData, i) ->
     newNode = document.createElementNS("http://www.w3.org/2000/svg", visData["shape"][i])
     d3.select(newNode).style("fill", visData["color"][i])
     d3.select(newNode).style("stroke", visData["stroke"][i])
     d3.select(newNode).attr("stroke-width", visData["stroke-width"][i])

     newTranslate = "translate(" + canvasWidth / 2 + "," + canvasWidth / 2 + ")"

     return {"shape": [], "color": [], "stroke": [], \
     "stroke-width": [], "width": [], "height": [], "area": [], "x-position": [], "y-position": []}
     */


    $(document).ready(function () {
        var connector, remappingForm;
        connector = new VisConnector();
        remappingForm = null;
        return window.connector = connector;
    });

    setupModal = function () {
        return $('table').on('contextmenu', function (event) {
            var scope;
            event.preventDefault();
            scope = angular.element(event.target).scope();
            scope.$apply(function () {
                return scope.selectDataSet(scope.dataSet);
            });
            return $("#attrEditor").modal();
        });
    };

}).call(this);
